<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>平滑代码实现 - 解决斜方向抖动问题</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        h1, h2, h3, h4 {
            color: #0066cc;
            margin-top: 1.5em;
            margin-bottom: 0.8em;
        }
        h1 {
            text-align: center;
            border-bottom: 2px solid #0066cc;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        .date {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-style: italic;
        }
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #0066cc;
            font-family: Consolas, Monaco, monospace;
            font-size: 14px;
        }
        code {
            font-family: Consolas, Monaco, monospace;
            color: #333;
        }
        .note {
            background-color: #e1f5fe;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #03a9f4;
        }
        .warning {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #ffc107;
        }
        .section {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin: 30px 0;
        }
        ol, ul {
            margin-left: 20px;
            padding-left: 20px;
        }
        li {
            margin-bottom: 8px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        img {
            max-width: 100%;
            display: block;
            margin: 20px auto;
            border-radius: 5px;
        }
        .footer {
            text-align: center;
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #666;
        }
        .comment {
            color: #008000;
        }
        .keyword {
            color: #0000ff;
        }
        .string {
            color: #a31515;
        }
        .toc {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #e0e0e0;
            margin: 20px 0;
        }
        .toc-title {
            font-weight: bold;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>平滑代码实现 - 解决斜方向抖动问题</h1>
    <div class="date">文档生成日期: 2025-05-31 23:56:55</div>

    <div class="toc">
        <div class="toc-title">目录</div>
        <ol>
            <li><a href="#introduction">问题介绍</a></li>
            <li><a href="#solution-overview">解决方案概述</a></li>
            <li><a href="#implementation">具体实现方法</a>
                <ol>
                    <li><a href="#frameset-changes">FrameSet.cs 修改</a></li>
                    <li><a href="#gamescene-changes">GameScene.cs 修改</a></li>
                    <li><a href="#mapobject-process-changes">MapObject.cs Process 方法修改</a></li>
                    <li><a href="#mapobject-changes">MapObject.cs UpdateFrame 方法修改</a></li>
                    <li><a href="#userobject-changes">UserObject.cs UpdateFrame 方法修改</a></li>
                </ol>
            </li>
            <li><a href="#config">配置说明</a></li>
            <li><a href="#results">效果展示</a></li>
            <li><a href="#conclusion">结论与总结</a></li>
        </ol>
    </div>

    <div class="section" id="introduction">
        <h2>1. 问题介绍</h2>
        <p>在传奇类游戏中，角色在进行斜向移动（如右上、左下等方向）时经常会出现抖动或闪烁现象。这不仅影响游戏的视觉体验，还会让玩家感到不适。</p>
        
        <p>这种斜向移动的抖动主要是由以下几个原因导致的：</p>
        <ul>
            <li>坐标计算中的取整操作导致精度损失</li>
            <li>奇偶像素修正机制在斜向移动时的不合理应用</li>
            <li>斜向移动时X和Y坐标同时变化带来的累积误差</li>
        </ul>
        
        <p>在原始代码中，无论何种方向移动都统一应用了偶数对齐修正（将坐标值减去其对2的余数）：</p>
        <pre><code>x -= x % 2;
y -= y % 2;</code></pre>
        <p>这种处理方式对直线移动（上下左右）是有效的，但对斜向移动却会导致明显的抖动现象。</p>
    </div>

    <div class="section" id="solution-overview">
        <h2>2. 解决方案概述</h2>
        <p>要解决角色斜向移动时的抖动问题，我们采用了以下几种优化策略：</p>

        <ol>
            <li><strong>平滑渲染</strong>：使用时间插值而非帧计数进行位置计算，增加移动的平滑性</li>
            <li><strong>选择性像素修正</strong>：仅对直线移动（上、下、左、右）应用偶数对齐修正，斜向移动时避免此类修正</li>
            <li><strong>移动帧机制优化</strong>：改进MoveFrame处理机制，使其在平滑渲染模式下更加连贯</li>
        </ol>

        <p>这些优化综合起来，可以大幅度减少斜向移动时的抖动现象，提供更加流畅的游戏体验。</p>

        <div class="note">
            <p>值得注意的是，虽然这些优化可以解决斜向移动抖动问题，但可能会导致一些轻微的阴影闪烁。在整体体验上，这种取舍是值得的，因为移动平滑度的提升远超过了偶尔的阴影闪烁带来的影响。</p>
        </div>
    </div>

    <div class="section" id="implementation">
        <h2>3. 具体实现方法</h2>
        <p>以下是具体的代码修改实现，涉及到多个文件的多处变更：</p>

        <div id="frameset-changes">
            <h3>3.1 FrameSet.cs 修改</h3>
            <p>在 Frame 类中添加 Sum 属性，用于计算帧序列的总时间，这对平滑渲染至关重要：</p>
            <pre><code>// 添加到 Frame 类中 (约 1159 行)
public double Sum
{
    get
    {
        TimeSpan sum = TimeSpan.Zero;
        foreach (var timeSpan in Delays)
            sum = sum.Add(timeSpan);
        return sum.TotalMilliseconds;
    }
}</code></pre>
            <p>这个属性计算了帧序列中所有延迟的总和，为基于时间的平滑插值移动提供了必要的数据基础。</p>
        </div>

        <div id="gamescene-changes">
            <h3>3.2 GameScene.cs 修改</h3>
            <p>修改 Process 方法中的 MoveFrame 处理逻辑，以适应平滑渲染模式：</p>
            <pre><code>// 修改前
if (CEnvir.Now >= MoveTime)
{
    MoveTime = CEnvir.Now.AddMilliseconds(100);
    MapControl.Animation++;
    MoveFrame = true;
}
else
{
    MoveFrame = false;
}

// 修改后 (约 1797 行)
if (CEnvir.Now >= MoveTime)
{
    MoveTime = CEnvir.Now.AddMilliseconds(100);
    MapControl.Animation++;
    MoveFrame = true;
}
else if (!Config.SmoothRendering)  // 仅在非平滑渲染模式下重置MoveFrame
{
    MoveFrame = false;
}</code></pre>
            <p>这个修改确保在启用平滑渲染时，MoveFrame 状态保持不变，从而使移动更加连贯。</p>
        </div>

        <div id="mapobject-process-changes">
            <h3>3.3 MapObject.cs Process 方法修改</h3>
            <p>注释掉 Process 方法中的 SmoothUpdateFrame 调用，避免与新的平滑渲染机制冲突：</p>
            <pre><code>// 修改前 (约 623 行)
if (Config.SmoothRendering)
    SmoothUpdateFrame();

// 修改后
//if (Config.SmoothRendering)
//    SmoothUpdateFrame();</code></pre>
            <p>这个修改移除了原有的平滑更新逻辑，因为我们将在 UpdateFrame 方法中实现更优的平滑处理。</p>
        </div>

        <div id="mapobject-changes">
            <h3>3.4 MapObject.cs UpdateFrame 方法修改</h3>
            <p>这是最核心的修改，实现了平滑移动和斜向修正：</p>
            <pre><code>public virtual void UpdateFrame()
{
    if (Frames == null || CurrentFrame == null) return;

    switch (CurrentAction)
    {
        case MirAction.Moving:
        case MirAction.Pushed:
            if (!GameScene.Game.MoveFrame) return;
            break;
    }

    int frame = CurrentFrame.GetFrame(FrameStart, CEnvir.Now, (this != User || GameScene.Game.Observer) && ActionQueue.Count > 1);

    if (frame == CurrentFrame.FrameCount || (Interupt && ActionQueue.Count > 0))
    {
        DoNextAction();
        frame = CurrentFrame.GetFrame(FrameStart, CEnvir.Now, (this != User || GameScene.Game.Observer) && ActionQueue.Count > 1);

        if (frame == CurrentFrame.FrameCount)
            frame = CurrentFrame.FrameCount - 1;
    }

    int x = 0, y = 0;

    switch (CurrentAction)
    {
        case MirAction.Moving:
        case MirAction.Pushed:
            if (!Config.SmoothRendering)
            {
                switch (Direction)
                {
                    case MirDirection.Up:
                        x = 0;
                        y = (int)(CellHeight * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        break;
                    case MirDirection.UpRight:
                        x = -(int)(CellWidth * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        y = (int)(CellHeight * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        break;
                    case MirDirection.Right:
                        x = -(int)(CellWidth * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        y = 0;
                        break;
                    case MirDirection.DownRight:
                        x = -(int)(CellWidth * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        y = -(int)(CellHeight * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        break;
                    case MirDirection.Down:
                        x = 0;
                        y = -(int)(CellHeight * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        break;
                    case MirDirection.DownLeft:
                        x = (int)(CellWidth * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        y = -(int)(CellHeight * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        break;
                    case MirDirection.Left:
                        x = (int)(CellWidth * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        y = 0;
                        break;
                    case MirDirection.UpLeft:
                        x = (int)(CellWidth * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        y = (int)(CellHeight * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        break;
                }
            }
            else
            {
                double sum = CurrentFrame.Sum;
                switch (Direction)
                {
                    case MirDirection.Up:
                        x = 0;
                        y = (int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.UpRight:
                        x = -(int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        y = (int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.Right:
                        x = -(int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        y = 0;
                        break;
                    case MirDirection.DownRight:
                        x = -(int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        y = -(int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.Down:
                        x = 0;
                        y = -(int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.DownLeft:
                        x = (int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        y = -(int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.Left:
                        x = (int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        y = 0;
                        break;
                    case MirDirection.UpLeft:
                        x = (int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        y = (int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                }
            }
            break;
    }
    
    // 解决斜方向抖动的核心改动
    if (Config.OptimizeDiagonalMovement)
    {
        switch (Direction)
        {
            case MirDirection.Up:
            case MirDirection.Right:
            case MirDirection.Down:
            case MirDirection.Left:
                x -= x % 2;
                y -= y % 2;
                break;
            default:
                // 斜向移动不做偶数修正，避免抖动
                // 注：不加修正可能会有轻微的阴影闪烁，但移动更平滑
                break;
        }
    }
    else
    {
        // 不优化则使用原始行为
        x -= x % 2;
        y -= y % 2;
    }

    if (CurrentFrame.Reversed)
    {
        frame = CurrentFrame.FrameCount - frame - 1;
        x *= -1;
        y *= -1;
    }
    
    MovingOffSet = new Point(x, y);
    
    if (CurrentAction == MirAction.Pushed)
    {
        frame = 0;
    }
    
    FrameIndex = frame;
    DrawFrame = FrameIndex + CurrentFrame.StartIndex + CurrentFrame.OffSet * (int)Direction;
}</code></pre>
            <p>关键的改动是将原来统一应用的偶数修正改为仅对直线移动应用，斜向移动则不做修正，这有效减少了抖动现象。</p>
        </div>

        <div id="userobject-changes">
            <h3>3.5 UserObject.cs UpdateFrame 方法修改</h3>
            <p>UserObject类需要处理传奇2和传奇3的资源，所以同样需要修改其UpdateFrame方法：</p>
            <pre><code>public override void UpdateFrame()
{
    // 需要同时计算传奇2帧和传奇3帧
    // 才能应对传2传3装备混穿的情况
    // 传2帧
    if (Mir2Frames == null || Mir2CurrentFrame == null) return;
    // 传3帧
    if (Frames == null || CurrentFrame == null) return;

    switch (CurrentAction)
    {
        case MirAction.Moving:
        case MirAction.Pushed:
            if (!GameScene.Game.MoveFrame) return;
            break;
    }

    // 拿到当前时间对应的那1帧
    int frame = CurrentFrame.GetFrame(FrameStart, CEnvir.Now, (this != User || GameScene.Game.Observer) && ActionQueue.Count > 1);
    // 传奇2当前帧
    int mir2Frame = Mir2CurrentFrame.GetFrame(FrameStart, CEnvir.Now, (this != User || GameScene.Game.Observer) && ActionQueue.Count > 1);

    if (frame == CurrentFrame.FrameCount || mir2Frame == Mir2CurrentFrame.FrameCount || (Interupt && ActionQueue.Count > 0))
    {
        DoNextAction();
        frame = CurrentFrame.GetFrame(FrameStart, CEnvir.Now, (this != User || GameScene.Game.Observer) && ActionQueue.Count > 1);
        // 传奇2当前帧
        mir2Frame = Mir2CurrentFrame.GetFrame(FrameStart, CEnvir.Now, (this != User || GameScene.Game.Observer) && ActionQueue.Count > 1);

        if (frame == CurrentFrame.FrameCount)
            frame -= 1;
        if (mir2Frame == Mir2CurrentFrame.FrameCount)
            mir2Frame -= 1;
    }

    int x = 0, y = 0;
    int mir2x = 0, mir2y = 0;
    
    #region 传奇2
    switch (CurrentAction)
    {
        case MirAction.Moving:
        case MirAction.Pushed:
            if (!Config.SmoothRendering)
            {
                switch (Direction)
                {
                    case MirDirection.Up:
                        mir2x = 0;
                        mir2y = (int)(CellHeight * MoveDistance / (float)Mir2CurrentFrame.FrameCount * (Mir2CurrentFrame.FrameCount - (mir2Frame + 1)));
                        break;
                    case MirDirection.UpRight:
                        mir2x = -(int)(CellWidth * MoveDistance / (float)Mir2CurrentFrame.FrameCount * (Mir2CurrentFrame.FrameCount - (mir2Frame + 1)));
                        mir2y = (int)(CellHeight * MoveDistance / (float)Mir2CurrentFrame.FrameCount * (Mir2CurrentFrame.FrameCount - (mir2Frame + 1)));
                        break;
                    case MirDirection.Right:
                        mir2x = -(int)(CellWidth * MoveDistance / (float)Mir2CurrentFrame.FrameCount * (Mir2CurrentFrame.FrameCount - (mir2Frame + 1)));
                        mir2y = 0;
                        break;
                    case MirDirection.DownRight:
                        mir2x = -(int)(CellWidth * MoveDistance / (float)Mir2CurrentFrame.FrameCount * (Mir2CurrentFrame.FrameCount - (mir2Frame + 1)));
                        mir2y = -(int)(CellHeight * MoveDistance / (float)Mir2CurrentFrame.FrameCount * (Mir2CurrentFrame.FrameCount - (mir2Frame + 1)));
                        break;
                    case MirDirection.Down:
                        mir2y = -(int)(CellHeight * MoveDistance / (float)Mir2CurrentFrame.FrameCount * (Mir2CurrentFrame.FrameCount - (mir2Frame + 1)));
                        mir2x = 0;
                        break;
                    case MirDirection.DownLeft:
                        mir2x = (int)(CellWidth * MoveDistance / (float)Mir2CurrentFrame.FrameCount * (Mir2CurrentFrame.FrameCount - (mir2Frame + 1)));
                        mir2y = -(int)(CellHeight * MoveDistance / (float)Mir2CurrentFrame.FrameCount * (Mir2CurrentFrame.FrameCount - (mir2Frame + 1)));
                        break;
                    case MirDirection.Left:
                        mir2x = (int)(CellWidth * MoveDistance / (float)Mir2CurrentFrame.FrameCount * (Mir2CurrentFrame.FrameCount - (mir2Frame + 1)));
                        mir2y = 0;
                        break;
                    case MirDirection.UpLeft:
                        mir2x = (int)(CellWidth * MoveDistance / (float)Mir2CurrentFrame.FrameCount * (Mir2CurrentFrame.FrameCount - (mir2Frame + 1)));
                        mir2y = (int)(CellHeight * MoveDistance / (float)Mir2CurrentFrame.FrameCount * (Mir2CurrentFrame.FrameCount - (mir2Frame + 1)));
                        break;
                }
            }
            else
            {
                double sum = CurrentFrame.Sum;
                switch (Direction)
                {
                    case MirDirection.Up:
                        mir2x = 0;
                        mir2y = (int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.UpRight:
                        mir2x = -(int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        mir2y = (int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.Right:
                        mir2x = -(int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        mir2y = 0;
                        break;
                    case MirDirection.DownRight:
                        mir2x = -(int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        mir2y = -(int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.Down:
                        mir2x = 0;
                        mir2y = -(int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.DownLeft:
                        mir2x = (int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        mir2y = -(int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.Left:
                        mir2x = (int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        mir2y = 0;
                        break;
                    case MirDirection.UpLeft:
                        mir2x = (int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        mir2y = (int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                }
            }
            break;
    }
    #endregion

    #region 传奇3
    // 计算传奇3部分的坐标
    switch (CurrentAction)
    {
        case MirAction.Moving:
        case MirAction.Pushed:
            if (!Config.SmoothRendering)
            {
                switch (Direction)
                {
                    case MirDirection.Up:
                        x = 0;
                        y = (int)(CellHeight * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        break;
                    case MirDirection.UpRight:
                        x = -(int)(CellWidth * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        y = (int)(CellHeight * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        break;
                    case MirDirection.Right:
                        x = -(int)(CellWidth * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        y = 0;
                        break;
                    case MirDirection.DownRight:
                        x = -(int)(CellWidth * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        y = -(int)(CellHeight * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        break;
                    case MirDirection.Down:
                        y = -(int)(CellHeight * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        x = 0;
                        break;
                    case MirDirection.DownLeft:
                        x = (int)(CellWidth * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        y = -(int)(CellHeight * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        break;
                    case MirDirection.Left:
                        x = (int)(CellWidth * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        y = 0;
                        break;
                    case MirDirection.UpLeft:
                        x = (int)(CellWidth * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        y = (int)(CellHeight * MoveDistance / (float)CurrentFrame.FrameCount * (CurrentFrame.FrameCount - (frame + 1)));
                        break;
                }
            }
            else
            {
                double sum = CurrentFrame.Sum;
                switch (Direction)
                {
                    case MirDirection.Up:
                        x = 0;
                        y = (int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.UpRight:
                        x = -(int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        y = (int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.Right:
                        x = -(int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        y = 0;
                        break;
                    case MirDirection.DownRight:
                        x = -(int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        y = -(int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.Down:
                        x = 0;
                        y = -(int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.DownLeft:
                        x = (int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        y = -(int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                    case MirDirection.Left:
                        x = (int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        y = 0;
                        break;
                    case MirDirection.UpLeft:
                        x = (int)(((CellWidth * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        y = (int)(((CellHeight * MoveDistance) / sum) * (sum - Math.Min((CEnvir.Now - FrameStart).TotalMilliseconds, sum)));
                        break;
                }
            }
            break;
    }
    #endregion

    // 解决斜方向抖动的核心修改点
    if (Config.OptimizeDiagonalMovement)
    {
        switch (Direction)
        {
            case MirDirection.Up:
            case MirDirection.Right:
            case MirDirection.Down:
            case MirDirection.Left:
                x -= x % 2;
                y -= y % 2;
                mir2x -= mir2x % 2;
                mir2y -= mir2y % 2;
                break;
            default:
                // 斜向移动不做偶数修正，可能会有轻微阴影闪烁，但移动更平滑
                break;
        }
    }
    else
    {
        // 不优化则使用原始行为
        x -= x % 2;
        y -= y % 2;
        mir2x -= mir2x % 2;
        mir2y -= mir2y % 2;
    }

    if (CurrentFrame.Reversed)
    {
        frame = CurrentFrame.FrameCount - frame - 1;
        x *= -1;
        y *= -1;
    }

    if (Mir2CurrentFrame.Reversed)
    {
        mir2Frame = Mir2CurrentFrame.FrameCount - mir2Frame - 1;
        mir2x *= -1;
        mir2y *= -1;
    }
    
    if (GameScene.Game.MapControl.BackgroundImage != null)
        GameScene.Game.MapControl.BackgroundMovingOffset = new Point((int)(x / GameScene.Game.MapControl.BackgroundScaleX), (int)(y / GameScene.Game.MapControl.BackgroundScaleY));

    MovingOffSet = new Point(x, y);

    if (CurrentAction == MirAction.Pushed)
    {
        frame = 0;
        mir2Frame = 0;
    }

    FrameIndex = frame;

    DrawFrame = FrameIndex + CurrentFrame.StartIndex + CurrentFrame.OffSet * (int)Direction;
    Mir2DrawFrame = mir2Frame + Mir2CurrentFrame.StartIndex + Mir2CurrentFrame.OffSet * (int)Direction;
}</code></pre>
            <p>在UserObject中需要同时处理传奇2和传奇3的资源，所以对两者都应用了同样的优化策略。</p>
        </div>
    </div>

    <div class="section" id="config">
        <h2>4. 配置说明</h2>
        <p>为了支持这些优化，需要在配置系统中添加相关选项。在Config.cs文件中添加：</p>
        <pre><code>// 添加到Config.cs中
public static bool SmoothRendering = true;           // 平滑渲染（基于时间的插值）
public static bool OptimizeDiagonalMovement = true;  // 优化斜向移动（减少抖动）</code></pre>
        
        <p>这些配置项可以通过游戏设置界面让玩家自行选择是否启用这些优化：</p>
        <pre><code>// 在设置UI中添加相关选项
private DXCheckBox _smoothRenderingBox;
private DXCheckBox _optimizeDiagonalMovementBox;

private void InitializeSettings()
{
    _smoothRenderingBox = new DXCheckBox
    {
        Parent = this,
        Label = { Text = "平滑渲染" },
        Hint = "使用基于时间的插值使移动更平滑",
        Checked = Config.SmoothRendering
    };
    
    _smoothRenderingBox.CheckedChanged += (o, e) =>
    {
        Config.SmoothRendering = _smoothRenderingBox.Checked;
        ConfigReader.Save();
    };
    
    _optimizeDiagonalMovementBox = new DXCheckBox
    {
        Parent = this,
        Label = { Text = "优化斜向移动" },
        Hint = "减少斜向移动时的抖动",
        Checked = Config.OptimizeDiagonalMovement
    };
    
    _optimizeDiagonalMovementBox.CheckedChanged += (o, e) =>
    {
        Config.OptimizeDiagonalMovement = _optimizeDiagonalMovementBox.Checked;
        ConfigReader.Save();
    };
}</code></pre>
    </div>

    <div class="section" id="results">
        <h2>5. 效果展示</h2>
        <p>通过上述优化，我们可以获得以下效果改善：</p>
        <ul>
            <li><strong>直线移动</strong>：保持和原来一样的平滑效果，没有抖动</li>
            <li><strong>斜向移动</strong>：大幅减少抖动现象，移动更加平滑自然</li>
            <li><strong>时间插值</strong>：使移动过程更加连续，不受帧率波动影响</li>
        </ul>

        <div class="note">
            <p>这些优化对游戏体验的提升是显著的，尤其是在角色需要频繁斜向移动的场景中。玩家将感受到更加流畅、自然的角色移动效果，减少了因为抖动带来的视觉疲劳。</p>
        </div>

        <p>在高帧率下，优化效果更加明显，角色移动将接近完美的平滑。即使在低帧率条件下，也能提供更好的移动体验。</p>
    </div>

    <div class="section" id="conclusion">
        <h2>6. 结论与总结</h2>
        <p>通过以上修改，我们成功解决了传奇类游戏中斜向移动的抖动问题。核心解决方案包括：</p>
        <ol>
            <li>利用时间插值替代基于帧的位置计算，提供更平滑的移动效果</li>
            <li>根据移动方向的不同选择性地应用像素修正，避免斜向移动时的抖动</li>
            <li>优化MoveFrame机制，使平滑渲染在各种帧率下都能正常工作</li>
        </ol>
        
        <p>这些优化虽然牺牲了一点点性能（时间插值计算比简单帧计算复杂一些），但带来的视觉体验提升是值得的。同时，我们也保留了原始行为的支持，通过配置选项让玩家可以根据自己的喜好和设备性能选择是否启用这些优化。</p>
        
        <p>尽管仍可能存在少量的阴影闪烁问题，但相较于明显的抖动，这是一个可以接受的折中方案。未来可以考虑进一步优化渲染系统，彻底解决这些微小的视觉瑕疵。</p>
    </div>

    <div class="footer">
        <p>文档生成日期: 2025-05-31 23:56:55</p>
        <p>© 91-Game 团队 - 技术文档</p>
    </div>
</body>
</html>